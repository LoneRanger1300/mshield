{"entries":[{"timestamp":1766706255322,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"custom.ts","patch":[{"start1":22,"length1":25,"diffs":[[1,"pxt_mshield - 1.1.1.tar"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":166,"length1":175,"diffs":[[1,"        \"tutorial-template\": \"github:loneranger1300/tutorial-template#ac37148fb64616a30037197e08887cd30079f4ed\"\n"]]},{"start1":402,"length1":56,"diffs":[[1,"        \"custom.ts\"\n"]]}]},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1766706255321,"editorVersion":"8.0.18","text":{"README.md":"\n# Siyeenove mShield extension\n\n![](/image.jpg/)\n\n> Open this page at [https://siyeenove.github.io/pxt_mshield/](https://siyeenove.github.io/pxt_mshield/)\n\nThis library is designed to drive mShield, You can get mShield here:   \n\n[Buy](https://www.amazon.com/dp/B0FQ5ZP1GW)    \n[SIYEENOVE](https://siyeenove.com/buy/)   \n\nProduct Tutorial: \n\n[SIYEENOVE](https://siyeenove.com/tutorial/)    \n[Github PDF](https://siyeenove.github.io/M1E0002/mShield%20Tutorial%20-%20English%202025-10-14.pdf)   \n\n## Code Example\n\n```JavaScript\n// Motor1 runs clockwise at full speed.   \nmShield.setMotorsDirectionSpeed(mShield.Motors.Motor1, mShield.MotorsDirection.CC, 100)   \n```\n\n```JavaScript\n//Set the speed and direction of motor1 and motor2 of mShield.   \nmShield.setMotorsSpeed(-100, 100)   \n```\n\n```JavaScript\n//Set mShield motor1 and motor2 to stop.    \nmShield.wheelStop(mShield.Motors.AllMotors)    \n```\n\n```JavaScript\n//When the speed of the motors of the mShield board is inconsistent due to hardware reasons, \n//this function adjusts the speed of the motors and is permanently stored inside the mShield.    \nmShield.motorsAdjustment(0, 0)    \n```\n\n```JavaScript\n//Light all the leds of the mShield board.     \nmShield.setLed(mShield.Leds.AllLED, true)    \n```\n\n```JavaScript\n//Read and display the value of the \"OK\" key of the infrared remote control.     \nmShield.irCallBack(function () {\n    if (mShield.irButton(mShield.MshieldIrButtons.OK)) {\n        basic.showNumber(mShield.irValue())\n    }\n})    \n```\n\n```JavaScript\n//Set S1 to S4 pin to PWM mode.    \nmShield.setS1ToS4Type(mShield.S1ToS4Type.PWM)\n\nbasic.forever(function () {\n    //The pulse width of pins S1 to S4 is set to 200.\n    mShield.extendPwmControl(mShield.PwmAndServoIndex.All, 200)\n})    \n```\n\n```JavaScript\n//Set S1 to S4 pin to servo mode.    \nmShield.setS1ToS4Type(mShield.S1ToS4Type.Servo)\n\nbasic.forever(function () {\n    //Set the 180° servo Angle from S1 to S4 pins to 0.\n    mShield.extendServoControl(mShield.PwmAndServoIndex.S1, mShield.ServoType.Servo180, 0)\n    basic.pause(1000)\n\n    //Set the 180° servo Angle from S1 to S4 pins to 180.\n    mShield.extendServoControl(mShield.PwmAndServoIndex.S1, mShield.ServoType.Servo180, 180)\n    basic.pause(1000)\n})   \n```\n\n```JavaScript\n//Set S1 to S4 pin to servo mode.    \nmShield.setS1ToS4Type(mShield.S1ToS4Type.Servo)\n\nbasic.forever(function () {\n    //Set the 360° servo of pins S1 to S4 to run forward at full speed.\n    mShield.continuousServoControl(mShield.PwmAndServoIndex.All, 100)\n    basic.pause(1000)\n\n    //Set the 360° servo of pins S1 to S4 to run backward at full speed.\n    mShield.continuousServoControl(mShield.PwmAndServoIndex.All, -100)\n    basic.pause(1000)\n})   \n```\n\n```JavaScript\n//Set mCar external 3 AA batteries, and infinite loop display power level.\nbasic.forever(function () {\n    basic.showNumber(mShield.batteryLevel(mShield.BatteryType.AA3))\n    basic.pause(1000)\n})\n```\n\n```JavaScript\n//Read the firmware version of the chip on the mShield.\nbasic.forever(function () {\n    basic.showString(mShield.readVersions())\n    basic.pause(1000)\n}) \n```\n\n## Supported targets\n\n* for PXT/microbit\n\n## License\n\n* MIT\n","main.ts":"/*\n* This extension library was developed by the SIYEENOVE team.\n* Date: Dec 9, 2024  \n*/\n//% weight=11 color=#FF5C00 block=\"mShield\" blockId=\"mShield\" icon=\"\\uf085\"\nnamespace mShield {\n    export enum MotorsDirection {\n        //%block=\"clockwise\"\n        CC = 1,\n        //%block=\"counterclockwise\"\n        CCW = 2,\n    }\n\n    export enum Motors {\n        //%block=\"motor1\"\n        Motor1 = 1,\n        //%block=\"motor2\"\n        Motor2 = 2,\n        //%block=\"all motors\"\n        AllMotors = 3\n    }\n\n    export enum Leds {\n        //%block=\"20% LED\"\n        LED20 = 1,\n        //%block=\"40% LED\"\n        LED40 = 2,\n        //%block=\"60% LED\"\n        LED60 = 3,\n        //%block=\"80% LED\"\n        LED80 = 4,\n        //%block=\"all LEDs\"\n        AllLED = 5\n    }\n\n    export enum LedState {\n        //%block=\"ON\"\n        ON = 1,\n        //%block=\"OFF\"\n        OFF = 0\n    }\n\n    export enum S1ToS4Type {\n        //%block=\"PWM\"\n        PWM = 1,\n        //%block=\"servo\"\n        Servo = 2\n    }\n\n    export enum PwmAndServoIndex {\n        //% block=\"S1\"\n        S1 = 1,\n        //% block=\"S2\"\n        S2 = 2,\n        //% block=\"S3\"\n        S3 = 3,\n        //% block=\"S4\"\n        S4 = 4,\n        //% block=\"S1-S4\"\n        All = 5\n    }\n\n    export enum ServoType {\n        //% block=\"90°\"\n        Servo90 = 1,\n        //% block=\"180°\"\n        Servo180 = 2,\n        //% block=\"270°\"\n        Servo270 = 3\n    }\n\n    export enum MshieldIrButtons {\n        //% block=\"1\"\n        Number1 = 0x45,\n        //% block=\"2\"\n        Number2 = 0x46,\n        //% block=\"3\"\n        Number3 = 0x47,\n        //% block=\"4\"\n        Number4 = 0x44,\n        //% block=\"5\"\n        Number5 = 0x40,\n        //% block=\"6\"\n        Number6 = 0x43,\n        //% block=\"7\"\n        Number7 = 0x07,\n        //% block=\"8\"\n        Number8 = 0x15,\n        //% block=\"9\"\n        Number9 = 0x09,\n        //% block=\"*\"\n        Star = 0x16,\n        //% block=\"0\"\n        Number0 = 0x19,\n        //% block=\"#\"\n        Hash = 0x0d,\n        //% block=\" \"\n        Unused1 = -1,\n        //% block=\"▲\"\n        Up = 0x18,\n        //% block=\" \"\n        Unused2 = -2,\n        //% block=\"◀\"\n        Left = 0x08,\n        //% block=\"OK\"\n        OK = 0x1c,\n        //% block=\"▶\"\n        Right = 0x5a,\n        //% block=\" \"\n        Unused3 = -3,\n        //% block=\"▼\"\n        Down = 0x52,\n        //% block=\" \"\n        Unused4 = -4\n    }\n\n    export enum BatteryType {\n        //% block=\"3 AA batteries\"\n        AA3 = 1,\n        //% block=\"4 AA batteries\"\n        AA4 = 2,\n        //% block=\"5 AA batteries\"\n        AA5 = 3,\n        //% block=\"6 AA batteries\"\n        AA6 = 4,\n        //% block=\"1 lithium battery\"\n        LithiumBattery1 = 5,\n        //% block=\"2 lithium batteries\"\n        LithiumBattery2 = 6\n    }\n\n    let motor1Speed = 0\n    let motor2Speed = 0\n\n    // For Ir receiver\n    let irVal = 0\n    let irstate: number;\n    let state: number;\n\n    //The I2C speed is 100Khz, and the slave address is 0x29\n    let i2cAddr: number = 0x29;\n\n    /**\n    * Set the speed and direction of the motors\n    * @param motor - The motors of mShield.\n    * @param direction - The motor goes clockwise or counterclockwise.\n    * @param speed - The speed at which the motor. eg: 0--100\n    */\n    //% group=\"Motors\"\n    //% block=\"set %motor %direction speed %speed\\\\%\"\n    //% speed.min=0 speed.max=100\n    //% speed.defl=0\n    //% weight=380\n    export function setMotorsDirectionSpeed(motor: Motors, direction: MotorsDirection, speed: number): void {\n        let i2cBuffer = pins.createBuffer(2)\n        \n        if (motor == Motors.Motor1 || motor == Motors.AllMotors) {\n            motor1Speed = speed;\n            i2cBuffer[0] = 0x09;\n            if (direction == MotorsDirection.CC)         //clockwise\n                i2cBuffer[1] = motor1Speed;\n            else if (direction == MotorsDirection.CCW)   //counterclockwise\n                i2cBuffer[1] = motor1Speed + 101;\n            pins.i2cWriteBuffer(i2cAddr, i2cBuffer);\n        }\n        if (motor == Motors.Motor2 || motor == Motors.AllMotors) {\n            motor2Speed = speed;\n            i2cBuffer[0] = 0x0a;\n            if (direction == MotorsDirection.CC)          //clockwise\n                i2cBuffer[1] = motor2Speed;\n            else if (direction == MotorsDirection.CCW)    //counterclockwise\n                i2cBuffer[1] = motor2Speed + 101;\n            pins.i2cWriteBuffer(i2cAddr, i2cBuffer)\n        }\n    }\n\n\n    /**\n     * Set the speed and direction of the motor.\n     * @param m1Speed - Set the speed and direction of the left motor.\n     * @param m2Speed - Set the speed and direction of the right motor.\n     */\n    //% group=\"Motors\"\n    //% block=\"set motor1 speed %m1Speed\\\\% motor2 speed %m2Speed\\\\%\"\n    //% m1Speed.min=-100 m1Speed.max=100\n    //% m2Speed.min=-100 m2Speed.max=100\n    //% weight=379\n    export function setMotorsSpeed(m1Speed: number, m2Speed: number): void {\n        let i2cBuffer = pins.createBuffer(2)\n        \n        i2cBuffer[0] = 0x09;\n        if (m1Speed > 0){\n            motor1Speed = m1Speed;\n            i2cBuffer[1] = motor1Speed;\n        }else{\n            motor1Speed = Math.abs(m1Speed);\n            i2cBuffer[1] = motor1Speed + 101;\n        }\n        pins.i2cWriteBuffer(i2cAddr, i2cBuffer);\n\n        i2cBuffer[0] = 0x0a;\n        if (m2Speed > 0){\n            motor2Speed = m2Speed;\n            i2cBuffer[1] = motor2Speed;\n        }else{\n            motor2Speed = Math.abs(m2Speed);\n            i2cBuffer[1] = motor2Speed + 101;\n        }\n        pins.i2cWriteBuffer(i2cAddr, i2cBuffer);\n    }\n\n    /** \n     * Motors stop.\n     * @param motor - The motors of mShield.\n     */\n    //% group=\"Motors\"\n    //% weight=378\n    //%block=\"set %motor to stop\"\n    export function wheelStop(motor: Motors): void {\n        let i2cBuffer = pins.createBuffer(2)\n\n        if (motor == Motors.Motor1 || motor == Motors.AllMotors) {\n            motor1Speed = 0;\n            i2cBuffer[0] = 0x09;\n            i2cBuffer[1] = motor1Speed;\n            pins.i2cWriteBuffer(i2cAddr, i2cBuffer);\n        }\n        if (motor == Motors.Motor2 || motor == Motors.AllMotors) {\n            motor2Speed = 0;\n            i2cBuffer[0] = 0x0a;\n            i2cBuffer[1] = motor2Speed;\n            pins.i2cWriteBuffer(i2cAddr, i2cBuffer);\n        }\n    }\n\n\n    /** \n     * Motors speed calibration.\n     * When the speed of the left and right motors of the mShield trolley is not consistent,\n     * this function can adjust the speed of the motor and save it permanently.\n     * @param offset1 - Motor1 offset. eg: -10--0\n     * @param offset1 - Motor2 offset. eg: -10--0\n     */\n    //% group=\"Motors\"\n    //% weight=377\n    //%block=\"motors speed offset: motor1 %offset1 motor2 %offset2\"\n    //% offset1.min=-10 offset1.max=0\n    //% offset2.min=-10 offset2.max=0\n    //% offset1.defl=0 offset2.defl=0\n    export function motorsAdjustment(offset1: number, offset2: number): void {\n        let buffer = pins.createBuffer(2)\n        offset1 = Math.map(offset1, -10, 0, 10, 0);\n        offset2 = Math.map(offset2, -10, 0, 10, 0);\n\n        buffer[0] = 0x07;\n        buffer[1] = offset1;\n        pins.i2cWriteBuffer(i2cAddr, buffer);\n        basic.pause(10);\n        \n        buffer[0] = 0x08;\n        buffer[1] = offset2;\n        pins.i2cWriteBuffer(i2cAddr, buffer);\n        basic.pause(10);\n    }\n\n    /**\n    * Set xxx% LEDs.\n    * @param led - Choose which leds to use.\n    * @param onOff - Turn LED on or off.\n    */\n    //% group=\"LEDs\"\n    //% block=\"set %led state $onOff\"\n    //% weight=370\n    //% onOff.shadow=toggleOnOff\n    export function setLed(led: Leds, onOff: boolean) {\n        let buf = pins.createBuffer(2)\n        if (onOff){\n            buf[1] = 1;\n        }else{\n            buf[1] = 0;\n        }\n        \n        if (led == Leds.LED20 || led == Leds.AllLED){\n            buf[0] = 0x0b;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n        if (led == Leds.LED40 || led == Leds.AllLED) {\n            buf[0] = 0x0c;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n        if (led == Leds.LED60 || led == Leds.AllLED) {\n            buf[0] = 0x0d;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n        if (led == Leds.LED80 || led == Leds.AllLED) {\n            buf[0] = 0x0e;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n    }\n\n    //% shim=mShieldInfrared::irCode\n    function irCode(): number {\n        return 0;\n    }\n\n    //const IR_EVENT_SOURCE = 5299\n    //const IR_EVENT_VALUE  = 3500\n    \n    /**\n      * Run code when a button is pressed on the IR remote.\n      */\n    //% group=\"Infrared sensor\"\n    //% weight=360\n    //% block=\"on IR receiving\"\n    export function irCallBack(handler: () => void) {\n        // handler is the functional argument to the irCallback function and is the block\n        // to be executed inside the irCallback function generation block.\n        pins.setPull(DigitalPin.P12, PinPullMode.PullUp)\n\n        // https://github.com/lancaster-university/codal-core/blob/8c8366f9a1e92da69f90fe816456c4b9c42ffd13/inc/core/CodalComponent.h#L85\n        // A trigger event is registered, and handler is the function to execute to trigger the event.\n        //control.onEvent(IR_EVENT_SOURCE, IR_EVENT_VALUE, handler)\n\n        control.inBackground(() => {\n            while (true) {\n                // irVal = 8-bit command + 8-bit command inverse code\n                irVal = irCode()\n                if (irVal > 0xff) {\n                    // Call the handler function directly.\n                    handler()  \n\n                    // Triggers the event, which fires the event registered above (control.onEvent()).\n                    //control.raiseEvent(IR_EVENT_SOURCE, IR_EVENT_VALUE, EventCreationMode.CreateAndFire)\n                }\n                basic.pause(20)\n            }\n        })\n    }\n\n\n    /**\n     * Select the value of the infrared key that you want to be pressed.\n     */\n    //% group=\"Infrared sensor\"\n    //% irButton.fieldEditor=\"gridpicker\"\n    //% irButton.fieldOptions.columns=3\n    //% irButton.fieldOptions.tooltips=\"false\"\n    //% block=\"IR button %irButton is pressed\"\n    //% weight=359\n    export function irButton(irButton: MshieldIrButtons): boolean {\n        return (irVal & 0x00ff) == irButton as number\n    }\n\n\n    /**\n     * Read IR value.\n     * The correct infrared key value can only be read\n     * when the infrared key value is not equal to 0 by logical judgment.\n     * Return the key value of the infrared remote control, only the instruction code.\n     */\n    //% group=\"Infrared sensor\"\n    //% block=\"IR value\"\n    //% weight=358\n    export function irValue(): number {\n        return irVal & 0x00ff;\n    }\n\n    /**\n     * Set the port type of S1-S4.\n     * @param type - PWM or servo.\n     */\n    //% group=\"PWM port\"\n    //% weight=350\n    //% block=\"set S1-S4 as %type ports\"\n    export function setS1ToS4Type(type: S1ToS4Type): void {\n        let buf = pins.createBuffer(2)\n        buf[0] = 0x0f;\n        buf[1] = type;\n        pins.i2cWriteBuffer(i2cAddr, buf);\n    }\n\n    /**\n     * mShield S1--S4 ports output PWM signals.\n     * @param index - S1--S4 ports.\n     * @param pulseWidth - Pulse width.\n     */\n    //% group=\"PWM port\"\n    //% weight=349\n    //% block=\"set %index PWM pluse width is %pulseWidth\"\n    //% pulseWidth.min=0 pulseWidth.max=200\n    //% pulseWidth.defl=0\n    export function extendPwmControl(index: PwmAndServoIndex, pulseWidth: number): void {\n        let buf = pins.createBuffer(2)\n\n        buf[1] = pulseWidth;\n        if (index == PwmAndServoIndex.S1 || index == PwmAndServoIndex.All){\n            buf[0] = 0x10;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n        if (index == PwmAndServoIndex.S2 || index == PwmAndServoIndex.All){\n            buf[0] = 0x11;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n        if (index == PwmAndServoIndex.S3 || index == PwmAndServoIndex.All){\n            buf[0] = 0x12;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n        if (index == PwmAndServoIndex.S4 || index == PwmAndServoIndex.All){\n            buf[0] = 0x13;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n    }\n\n    /**\n     * Servo control module, used for 90, 180, 270 degrees servo.\n     * When the S1--S4 ports of mShield are connected to the servo, this function can control the servo.\n     * @param servoType - Servo type.\n     * @param index - Servo interface on mShield.\n     * @param angle - The Angle of rotation of the servo.\n     */\n    //% group=\"PWM port\"\n    //% weight=348\n    //% block=\"set %index %servoType servo angle to %angle°\"\n    //% angle.defl=0\n    export function extendServoControl(index: PwmAndServoIndex, servoType: ServoType, angle: number): void {\n        let angleMap: number\n        if (servoType == ServoType.Servo90) {\n            angleMap = Math.map(angle, 0, 90, 50, 250);\n        }else if (servoType == ServoType.Servo180) {\n            angleMap = Math.map(angle, 0, 180, 50, 250);\n        }else if (servoType == ServoType.Servo270) {\n            angleMap = Math.map(angle, 0, 270, 50, 250);\n        }\n\n        let buf = pins.createBuffer(2)\n        buf[1] = angleMap;\n        if (index == PwmAndServoIndex.S1){\n            buf[0] = 0x14;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n        if (index == PwmAndServoIndex.S2){\n            buf[0] = 0x15;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n        if (index == PwmAndServoIndex.S3){\n            buf[0] = 0x16;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n        if (index == PwmAndServoIndex.S4){\n            buf[0] = 0x17;\n            pins.i2cWriteBuffer(i2cAddr, buf);\n        }\n    }\n\n\n    /**\n     * The steering gear rotates continuously, and is used for the steering gear of 360 degrees rotation.\n     * @param index - Servo interface on mShield. \n     * @param speed - The speed at which the servo rotates.\n     */\n    //% group=\"PWM port\"\n    //% weight=347\n    //% block=\"set %index 360° servo speed to %speed\\\\%\"\n    //% speed.min=-100 speed.max=100\n    //% speed.defl=0\n    export function continuousServoControl(index: PwmAndServoIndex, speed: number): void {\n        speed = Math.map(speed, -100, 100, 0, 180)\n        extendServoControl(index, ServoType.Servo180, speed)\n    }\n\n\n    /**\n     * Sets the battery type and returns the battery level.\n     * @param batType - Type of battery. \n     * Return 0--100\n     */\n    //% group=\"Battery\"\n    //% weight=340\n    //% block=\"battery level: %batType\"\n    export function batteryLevel(batType: BatteryType) : number {\n        let i2cBuffer = pins.createBuffer(1);\n        if (batType == BatteryType.AA3)\n            i2cBuffer[0] = 0x01;\n        else if (batType == BatteryType.AA4)\n            i2cBuffer[0] = 0x02;\n        else if (batType == BatteryType.AA5)\n            i2cBuffer[0] = 0x03;\n        else if (batType == BatteryType.AA6)\n            i2cBuffer[0] = 0x04;\n        else if (batType == BatteryType.LithiumBattery1)\n            i2cBuffer[0] = 0x05;\n        else if (batType == BatteryType.LithiumBattery2)\n            i2cBuffer[0] = 0x06;\n        pins.i2cWriteBuffer(i2cAddr, i2cBuffer);\n\n        let batLevel = pins.i2cReadNumber(i2cAddr, NumberFormat.UInt8LE, false);\n        if (batLevel>100)\n            batLevel = 100;\n        \n        return batLevel; \n    }\n\n    /**\n     * Read the firmware version of the chip on the mShield.\n     * Returns a string. eg：\"Vx\"\n     */\n    //% group=\"Others\"\n    //% weight=330\n    //% block=\"version number\"\n    export function readVersions(): string {\n        let mCarVersions: number = 0;\n\n        let i2cBuffer = pins.createBuffer(1);\n        i2cBuffer[0] = 0x00;\n\n        pins.i2cWriteBuffer(i2cAddr, i2cBuffer)\n        mCarVersions = pins.i2cReadNumber(i2cAddr, NumberFormat.UInt8LE, false)\n\n        return (\"V\" + convertToText(mCarVersions))\n    }\n}\n","IR.cpp":"#include \"pxt.h\"\n\n//% color=50 weight=80\n//% icon=\"\\uf1eb\"\nnamespace mShieldInfrared { \n    int ir_code = 0x00;\n    int ir_addr = 0x00;\n    int data;\n\n    int logic_value(){   //A function to read the logical values \"0\" and \"1\".\n        uint32_t lasttime = system_timer_current_time_us();\n        uint32_t nowtime;\n        while(!uBit.io.P12.getDigitalValue());                          //Wait for the low level\n        nowtime = system_timer_current_time_us();\n        if((nowtime - lasttime) > 350 && (nowtime - lasttime) < 850){   //low level 560us\n            while(uBit.io.P12.getDigitalValue());                       //high level, wait\n            lasttime = system_timer_current_time_us();\n            if((lasttime - nowtime)>350 && (lasttime - nowtime) < 850){ //low level 560us\n                return 0;\n            }else if((lasttime - nowtime)>1350 && (lasttime - nowtime) < 1950){//high leve 1.7ms\n                return 1;\n        }\n        }\n        //uBit.serial.printf(\"error\\r\\n\");\n        return -1;\n    }\n\n    void pulse_deal(){\n        int i;\n        int num;\n        ir_addr=0x00;  //clear operation\n        for(i=0; i<16;i++ )\n        {\n            num = logic_value();\n            if(num == 1)\n            {\n                ir_addr |=(1<<i);\n            }else if (num == -1) {\n                ir_addr = 0;\n                break;\n            }\n        }\n        //Parse the CMD instruction in the remote control encoding.\n        ir_code=0x00;  //clear operation\n        for(i=0; i<16;i++ )\n        {\n            if(logic_value() == 1)\n            {\n                ir_code |=(1<<i);\n            }else if (num == -1) {\n                ir_code = 0; \n                break;\n            }\n        }\n    }\n\n    void remote_decode(void){\n        data = 0x00;\n        uint32_t lasttime = system_timer_current_time_us();\n        uint32_t nowtime;\n        while(uBit.io.P12.getDigitalValue()){//high level, wait\n            nowtime = system_timer_current_time_us();\n            if((nowtime - lasttime) > 100000){//More than 100 milliseconds, indicating that no key was pressed.\n                ir_code = 0xffff;\n                return;\n            }\n        }\n        //If the high level does not last more than 100ms\n        lasttime = system_timer_current_time_us();\n        while(!uBit.io.P12.getDigitalValue());//low level, wait\n        nowtime = system_timer_current_time_us();\n        if((nowtime - lasttime) < 10000 && (nowtime - lasttime) > 5000){//9ms\n            while(uBit.io.P12.getDigitalValue());//high level, wait\n            lasttime = system_timer_current_time_us();\n            // 4.5ms, the infrared protocol header is received and the data is newly sent. Start parsing logic 0 and 1\n            if((lasttime - nowtime) > 4000 && (lasttime - nowtime) < 5000){\n                pulse_deal();\n                //uBit.serial.printf(\"addr=0x%X,code = 0x%X\\r\\n\",ir_addr,ir_code);\n                data = ir_code;\n                return;//ir_code;\n            //2.25ms, which means the same packet was sent as the previous one\n            }else if((lasttime - nowtime) > 2000 && (lasttime - nowtime) < 2500){\n                while(!uBit.io.P12.getDigitalValue());//low level, wait\n                nowtime = system_timer_current_time_us();\n                if((nowtime - lasttime) > 500 && (nowtime - lasttime) < 700){//560us\n                    //uBit.serial.printf(\"addr=0x%X,code = 0x%X\\r\\n\",ir_addr,ir_code);\n                    data = ir_code;\n                    return;//ir_code;\n                }\n            }\n        }\n    }\n\n    //% \n    int irCode(){\n        remote_decode();\n        return data;\n    }\n\n    //%\n    int readPulseIn(int status){\n        uint32_t lasttime,nowtime,temp;\n        if(status == 1){//HIGH\n            lasttime = system_timer_current_time_us();\n            while(!uBit.io.P12.getDigitalValue()){ \n                temp = system_timer_current_time_us();\n                if((temp - lasttime) > 70000){\n                    //uBit.serial.printf(\"time out 0 %d\\r\\n\",(temp-lasttime));\n                    return -1;\n                }\n            }\n            lasttime = system_timer_current_time_us();\n            while(uBit.io.P12.getDigitalValue()){\n                if((system_timer_current_time_us() - lasttime) > 70000){\n                    //uBit.serial.printf(\"time out 1\");\n                    return -1;\n                }\n            }\n            nowtime = system_timer_current_time_us();\n        }else{//LOW\n            while(uBit.io.P12.getDigitalValue()){\n                if((system_timer_current_time_us() - lasttime) > 70000){\n                    //uBit.serial.printf(\"time out 3\");\n                    return -1;\n                }\n            }\n            lasttime = system_timer_current_time_us();\n            while(!uBit.io.P12.getDigitalValue()){\n                if((system_timer_current_time_us() - lasttime) > 70000){\n                    //uBit.serial.printf(\"time out 4\");\n                    return -1;\n                }\n            }\n            nowtime = system_timer_current_time_us();\n        }\n        return (nowtime - lasttime);\n    }\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n    //% color=50 weight=80\n    //% icon=\"\\uf1eb\"\ndeclare namespace mShieldInfrared {\n}\n\n// Auto-generated. Do not edit. Really.\n","enums.d.ts":"// Auto-generated. Do not edit.\ndeclare namespace mShieldInfrared {\n}\n\n// Auto-generated. Do not edit. Really.\n","custom.ts":"// Add your code here\npxt_mshield - 1.1.1.tar","pxt.json":"{\n    \"name\": \"mshield\",\n    \"version\": \"1.1.2\",\n    \"description\": \"mShield designed by Siyeenove\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"tutorial-template\": \"github:loneranger1300/tutorial-template#ac37148fb64616a30037197e08887cd30079f4ed\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.ts\",\n        \"IR.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"custom.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"8.0.18\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n\n// Read infrared remote control key value loop function.\nmShield.irCallBack(function () {\n    // Judge the received key value\n    if (mShield.irButton(mShield.MshieldIrButtons.Number1)) {\n        // The four LED lights of the expansion board are on for 1 second.\n        mShield.setLed(mShield.Leds.AllLED, true)\n        basic.pause(1000)\n    }\n    if (mShield.irButton(mShield.MshieldIrButtons.Number2)) {\n        // The four LED lights of the expansion board are off for 1 second.\n        mShield.setLed(mShield.Leds.AllLED, false)\n        basic.pause(1000)\n    }\n})\n// The speed compensation value of the 2 motors is set to 0.\nmShield.motorsAdjustment(0, 0)\nbasic.forever(function () {\n    // 2 motors are running forward for 1 second.\n    mShield.setMotorsDirectionSpeed(mShield.Motors.AllMotors, mShield.MotorsDirection.CC, 100)\n    basic.pause(1000)\n    // The 2 motors are stopped for 1 second.\n    mShield.setMotorsDirectionSpeed(mShield.Motors.AllMotors, mShield.MotorsDirection.CC, 0)\n    basic.pause(1000)\n    // The 2 motors are reversed for 1 second.\n    mShield.setMotorsDirectionSpeed(mShield.Motors.AllMotors, mShield.MotorsDirection.CCW, 100)\n    basic.pause(1000)\n    // The 2 motors are stopped for 1 second.\n    mShield.setMotorsDirectionSpeed(mShield.Motors.AllMotors, mShield.MotorsDirection.CCW, 0)\n    basic.pause(1000)\n    // Set the S1--S4 interface of the expansion board to PWM mode.\n    mShield.setS1ToS4Type(mShield.S1ToS4Type.PWM)\n    basic.pause(1000)\n    // S1--S4 PWM interface output 200 value, 100% duty cycle.\n    mShield.extendPwmControl(mShield.PwmAndServoIndex.All, 200)\n    basic.pause(1000)\n    // S1--S4 PWM interface output 0 value, 0% duty cycle.\n    mShield.extendPwmControl(mShield.PwmAndServoIndex.All, 0)\n    basic.pause(1000)\n    // Set the S1--S4 interface of the expansion board to drive servo mode.\n    mShield.setS1ToS4Type(mShield.S1ToS4Type.Servo)\n    basic.pause(1000)\n    // The servo of S1--S4 interface is turned to 180 degrees.\n    mShield.extendServoControl(mShield.PwmAndServoIndex.All, mShield.ServoType.Servo180, 0)\n    basic.pause(1000)\n    // The servo of S1--S4 interface is turned to 0 degrees.\n    mShield.extendServoControl(mShield.PwmAndServoIndex.All, mShield.ServoType.Servo180, 180)\n    basic.pause(1000)\n    // Set the S1--S4 interface of the expansion board to drive servo mode.\n    mShield.setS1ToS4Type(mShield.S1ToS4Type.Servo)\n    basic.pause(1000)\n    // 360-degree servo maximum speed forward rotation.\n    mShield.continuousServoControl(mShield.PwmAndServoIndex.All, 100)\n    basic.pause(1000)\n    // 360-degree servo stop.\n    mShield.continuousServoControl(mShield.PwmAndServoIndex.All, 0)\n    basic.pause(1000)\n    // 360-degree servo maximum speed reversal.\n    mShield.continuousServoControl(mShield.PwmAndServoIndex.All, -100)\n    basic.pause(1000)\n    // 360-degree servo stop.\n    mShield.continuousServoControl(mShield.PwmAndServoIndex.All, 0)\n    basic.pause(1000)\n    // Read the power level of the 3-connected AA battery.\n    basic.showNumber(mShield.batteryLevel(mShield.BatteryType.AA3))\n    basic.pause(1000)\n    // Read the extension board firmware version.\n    basic.showString(mShield.readVersions())\n    basic.pause(1000)\n})"}}],"shares":[],"lastSaveTime":1766706710731}